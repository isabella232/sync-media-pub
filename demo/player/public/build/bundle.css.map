{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "TextAsset.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport {SyncMedia} from './synclib/index.js';\n\timport {syncMedia, canGotoNext, canGotoPrevious, currentTimegraphEntry} from './store.js';\n\timport AudioAsset from './AudioAsset.svelte';\n\timport TextAsset from './TextAsset.svelte';\n\n\tlet userOk = false;\n\tlet giveOk = () => userOk = true;\n\n\tfunction mediaDone(event) {\n\t\tsyncMedia.next();\n\t};\n\n\tasync function loadSyncMedia() {\n\t\tlet file = '/fairytale/THE-MASTER-CAT;-OR,-PUSS-IN-BOOTS.xml';\n\t\tlet url = new URL(file, document.baseURI);\n\t\tlet parsedSyncMedia = new SyncMedia();\n\t\tawait parsedSyncMedia.loadUrl(url);\n\t\tsyncMedia.set(parsedSyncMedia);\n\t\treturn syncMedia;\n\t}\n\n\tlet promise = loadSyncMedia();\n\n</script>\n\n{#if !userOk}\n<!-- browsers won't start media playback without the user \"interacting\" with the page, \n\tso this is a cheap way to accommodate that -->\n<button on:click={giveOk}>Start!</button>\n{:else}\n{#await promise }\n\n<p>Loading...</p>\n\n{:then}\n<!-- for every asset, create a renderer that will respond to updates to data in the store -->\n{#each $syncMedia.assets.filter(a => a.type == \"audio\") as asset}\n<AudioAsset {asset} on:done={mediaDone}/>\n{/each}\n\n<div class=\"texts\">\n\t{#each $syncMedia.assets.filter(a => a.type == \"text\") as asset}\n\t<TextAsset {asset}/>\n\t{/each}\n</div>\n\n<div class=\"images\">\n\t{#each $syncMedia.assets.filter(a => a.type == \"image\") as asset}\n\t<ImageAsset {asset}/>\n\t{/each}\n</div>\n\n<div class=\"videos\">\n\t{#each $syncMedia.assets.filter(a => a.type == \"video\") as asset}\n\t<VideoAsset {asset}/>\n\t{/each}\n</div>\n\n<button on:click={syncMedia.previous} disabled='{!$canGotoPrevious}'>Previous</button>\n<button on:click={syncMedia.next} disabled='{!$canGotoNext}'>Next</button>\n\n{/await}\n{/if}\n<style>\n\tbutton {\n\t\tdisplay: inline;\n\t\tmargin-right: 2rem;\n\t}\n\tdiv.texts {\n\t\tdisplay: flex;\n\t}\n</style>",
    "<script>\n    import { onMount } from 'svelte';\n    import { currentTimegraphEntry } from './store.js';\n    export let asset;\n\n    let iframe;\n    let startEvent;\n    let endEvent;\n\n    let isInViewport = (elm, doc=iframe.contentDocument) => {\n        let bounding = elm.getBoundingClientRect();\n        return (\n            bounding.top >= 0 &&\n            bounding.left >= 0 &&\n            bounding.bottom <= (doc.defaultView.innerHeight || doc.documentElement.clientHeight) &&\n            bounding.right <= (doc.defaultView.innerWidth || doc.documentElement.clientWidth)\n        );\n    };\n\n    let applyStyle = () => {\n        if (iframe.contentDocument) {\n            let oldElms = Array.from(iframe.contentDocument.querySelectorAll(\".\" + startEvent.node.params.cssClass));\n            oldElms.map(oldElm => oldElm.classList.remove(startEvent.node.params.cssClass));\n            let elm = iframe.contentDocument.querySelector(startEvent.node.selector);\n            // apply params\n            if (startEvent.node.params.cssClass) {\n                elm.classList.add(startEvent.node.params.cssClass);\n            }\n            if (!isInViewport(elm)) {\n                elm.scrollIntoView();\n            }\n        }\n    };\n\n    async function loadIframe(asset) {\n        console.log(\"loading text\", asset.src.href);\n        return new Promise((resolve, reject) => {\n            //let iframeElement = document.querySelector(\"iframe\");\n            iframe.onload = () => {\n                console.log(\"loaded text\", iframe.src);\n                resolve();     \n            };\n            iframe.setAttribute('src', asset.src.href);\n        });\n    }\n\n    onMount(async () => {\n        console.log(\"text onmount\", asset);\n        await loadIframe(asset);\n        update();\n    });\n\n    currentTimegraphEntry.subscribe(() => {\n        if (iframe) update();\n    });\n    \n    function update() {\n        console.log(\"Current tg point\", $currentTimegraphEntry);\n        // events relevant to this asset\n        let events = $currentTimegraphEntry.events.filter(event => \n            event.node.type == \"text\" &&\n            event.node.src.href == asset.src);\n        startEvent = events.find(event => event.eventType == \"start\");\n        endEvent = events.find(event => event.eventType == \"end\");\n\n        if (startEvent) {\n            console.log(\"showing iframe\", iframe.src);\n            iframe.classList.remove(\"nodisplay\");\n            applyStyle();\n        }\n        if (endEvent && !startEvent) {\n            console.log(\"hiding iframe\", iframe.src);\n            iframe.classList.add(\"nodisplay\");\n        }\n    }\n    \n</script>\n<iframe class=\"nodisplay\" bind:this={iframe}></iframe>\n\n<style>\n    iframe {\n        height: 40rem;\n        width: 40rem;\n    }\n    iframe.nodisplay {\n        display: none;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "AAiEC,MAAM,eAAC,CAAC,AACP,OAAO,CAAE,MAAM,CACf,YAAY,CAAE,IAAI,AACnB,CAAC,AACD,GAAG,MAAM,eAAC,CAAC,AACV,OAAO,CAAE,IAAI,AACd,CAAC;ACSE,MAAM,cAAC,CAAC,AACJ,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,AAChB,CAAC,AACD,MAAM,UAAU,cAAC,CAAC,AACd,OAAO,CAAE,IAAI,AACjB,CAAC"
}